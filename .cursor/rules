Below is a practical blueprint for turning the existing React / Tailwind project into the “Kindle-style” reader you described:
1. UX PRINCIPLES
Minimal reading surface
One scrollable article-like column (no page breaks, no 600-word slicing for the UI).
Reader settings (font, width, line-height, TTS) auto-hide after a few seconds of inactivity – you already have this pattern in DocumentReader / EnhancedDocumentReader.
All AI affordances stay invisible until the reader explicitly:
highlights text ➜ small inline toolbar (“Explain”, “Analyze …”).
presses the floating AI-chat button ➜ opens side panel.
hovers a word ➜ shows “Click for definition …” tooltip.
2. KEEP FULL-TEXT RENDERING UNBROKEN
UI:
The components already render the entire docData.content string in one pass (see DocumentReader.processContent).
Backend:
For LLM calls you can still chunk the text internally (e.g. 2 000 tokens) but that should happen inside the hook (useAI / useAdvancedAI) – never touch the DOM representation.
Quick check: you are not slicing anywhere in the UI, only here:
Apply
That 3 000-char slice is just to limit the prompt size. Safe.
3. CONTEXT-AWARE AI
a) Selection based
You already forward the highlighted passage (≈ perfect).
b) Hover “thought prompts”
handleWordHover creates a tooltip.
On click of a word you can call:
Apply
Add throttling so it doesn’t fire for every fleeting hover.
c) Free-form chat
Side panel (AIPanel) receives either the selected text or a fallback document.content slice.
Inside useAI.generateResponse build prompts like:
Apply
Use embeddings / RAG later, but this is enough for a prototype.
4. STRUCTURE FOR LARGE BOOKS
• Store the raw text once in React state / Redux / IndexedDB.
Maintain an array of chapter start indices in document.chapters.
For scroll position ⇄ chapter sync:
Apply
This preserves continuous scrolling while still letting you show “Chapter n of m” in the control pop-over.
5. OPTIONAL ENHANCEMENTS
• Voice: useVoiceSynthesis is already wired; expose “Read paragraph” in the selection toolbar.
ElevenLabs: swap window.speechSynthesis for their REST if desired.
Concept map: keep off-canvas and summon with a discreet icon.
Persist reader prefs (font etc.) in localStorage.
6. WHAT TO DELETE / AVOID
✗ Any UI that paginates by fixed word counts.
✗ Auto-popping AI answers.
✗ Gamified badges / quizzes unless explicitly requested.
7. QUICK CODE TOUCH-UPS
1. Prevent accidental text-split optimisation:
Apply
Add click-for-definition:
Apply
Persist reader settings:
Apply
RESULT
You’ll have a distraction-free, continuous-scroll reader; AI hides until invoked; full-document context is preserved for every call; and the UI feels like Chrome’s Reading Mode with superpowers.